\section{Meilenstein 4 $-$ Microservices}

Da es auf unserer Seite zu Missverst\"andnissen bez\"uglich
der Entities der Context Map gekommen ist, haben wir die
Context Map mit den Entities aus unserem logischen
Datenmodell anstelle der des fachlichen Datenmodells
gef\"ullt und unsere weitere Arbeit auf dieser
Map durchgef\"uhrt, was, unserer Meinung nach, sowohl f\"ur
die Aggregates als auch f\"ur das Modell besser ist, da es
n\"aher an der tats\"achlichen Implementierung ist und
somit auch der Vergleich zum monolitischen Modell aus
Meilenstein 2 (vgl. \ref{ms2_3}) besser m\"oglich macht, da
beide Modelle auf den selben Entities (vgl. \ref{ldgo})
beruhen.

Um konsistent mit Meilenstein 2 (Kapitel \ref{ms2}) zu
bleiben, gehen wir auch hier von der von uns get\"atigten
Annahme aus, dass es ein Subsystem Buchhaltung gibt.

% Teilaufgabe 1 {{{
\subsection{Teilaufgabe 1: Context Map (Entities aus
  unserem fachlichen Datenmodell)}

\subsubsection*{Diese Map und diese Tabelle wurden
  nachtr\"aglich hinzugef\"ugt.}

\textbf{Anmerkung:} im Folgenden ist der Ausdruck Subsytem
equivalent zum Ausdruck Dom\"ane.

% Map {{{
\subsubsection{Context Map}
\input{ms4/context_map2}
% }}}

% Tabelle {{{
\subsubsection{Tabelle der \"Uberlappungstypen}

\begin{tabu} to \linewidth {p{1.8cm}|p{2.2cm}|X|X}
% Headerzeile {{{
\hline\rowcolor{codebordercolor}
Entity &\"Uberlappung mit anderer Dom\"ane
  &\"Uberlappungstyp &Begr\"undung \\
% }}}
% Bestellung {{{
\hline
Bestellung &Buchhaltung &Customer / Supplier (unser
  Subsystem als Eigent\"umer) &Die Buchhaltung ruft die
  Bestellungsdaten bei uns ab. Da wir der Eigent\"umer der
  Entity sind und wir nicht wissen wie komplex die Anbinung
  unserer Schnittstelle an die Buchhaltungssoftware
  (wahrscheinlich propriet\"are Anwendung) ist, Seperate
  Ways (der Verzicht auf den Aufruf unserer Schnittstelle
  auf Seiten der Buchhaltung) allerdings im Kontext
  unm\"oglich ist, haben wir uns f\"ur Customer / Supplier
  entschieden. \\
% }}}
% Gericht {{{
\hline
Gericht &Rezeptver\-waltung &Customer / Supplier
  (Rezeptverwaltung als Eigent\"umer) &Wir rufen
  die Gerichte beim Subsystem Rezeptverwaltung ab. Das
  Subsystem Rezeptverwaltung ist der Eigent\"umer und wir
  haben (brauchen) nur lesenden Zugriff auf das Entity
  Gericht. Customer / Supplier, da wir auf Augenh\"ohe mit
  der Rezeptverwaltung sind uns eine enge Zusammenarbeit
  m\"oglich ist. \\
% }}}
% Speisekarte {{{
\hline
Speisekar\-te &Rezeptver\-waltung &Customer / Supplier
  (Rezeptverwaltung als Eigent\"umer) &vgl. Entity Gericht.
  \\
% }}}
% Zubereitungsanleitung {{{
\hline
Zuberei\-tungsanlei\-tung &Rezeptver\-waltung &
  Customer / Supplier (Rezeptverwaltung als Eigent\"umer)
  &vgl. Entity Gericht. \\
% }}}
% Zutat {{{
\hline
Gast &Tischreser\-vierung &Shared Kernel &Gast hat keinen
  klaren Eigent\"umer, beide Subsysteme sind
  gleichberechtigt und eine enge Zusammenarbeit ist
  m\"oglich, ergo Shared Kernel. \\
% }}}
\hline
\end{tabu}
% }}}

\subsection{Teilaufgabe 1: Context Map (Entities aus
  unserem logischen Datenmodell)}

\subsubsection*{Auf dieser Map und dieser Tabelle
  beruhen die nachfolgenden Kapitel.}

\textbf{Anmerkung:} im Folgenden ist der Ausdruck Subsytem
equivalent zum Ausdruck Dom\"ane.

% Map {{{
\subsubsection{Context Map}
\input{ms4/context_map}
% }}}

\newpage

% Tabelle {{{
\subsubsection{Tabelle der \"Uberlappungstypen}

\begin{longtabu} to \linewidth {p{1.8cm}|p{2.2cm}|X|X}
% Headerzeile {{{
\hline\rowcolor{codebordercolor}
Entity &\"Uberlappung mit anderer Dom\"ane
  &\"Uberlappungstyp &Begr\"undung \\
% }}}
% Bestellung {{{
\hline
Bestellung &Buchhaltung &Customer / Supplier (unser
  Subsystem als Eigent\"umer) &Die Buchhaltung ruft die
  Bestellungsdaten bei uns ab. Da wir der Eigent\"umer der
  Entity sind und wir nicht wissen wie komplex die Anbinung
  unserer Schnittstelle an die Buchhaltungssoftware
  (wahrscheinlich propriet\"are Anwendung) ist, Seperate
  Ways (der Verzicht auf den Aufruf unserer Schnittstelle
  auf Seiten der Buchhaltung) allerdings im Kontext
  unm\"oglich ist, haben wir uns f\"ur Customer / Supplier
  entschieden. \\
% }}}
% Gericht {{{
\hline
Gericht &Rezeptver\-waltung &Customer / Supplier
  (Rezeptverwaltung als Eigent\"umer) &Wir rufen
  die Gerichte beim Subsystem Rezeptverwaltung ab. Das
  Subsystem Rezeptverwaltung ist der Eigent\"umer und wir
  haben (brauchen) nur lesenden Zugriff auf das Entity
  Gericht. Customer / Supplier, da wir auf Augenh\"ohe mit
  der Rezeptverwaltung sind uns eine enge Zusammenarbeit
  m\"oglich ist. \\
% }}}
% Speisekarte {{{
\hline
Speisekar\-te &Rezeptver\-waltung &Customer / Supplier
  (Rezeptverwaltung als Eigent\"umer) &vgl. Entity Gericht.
  \\
% }}}
% Zubereitungsanleitung {{{
\hline
Zuberei\-tungsanlei\-tung &Rezeptver\-waltung &
  Customer / Supplier (Rezeptverwaltung als Eigent\"umer)
  &vgl. Entity Gericht. \\
% }}}
% Zutat {{{
\hline
Zutat &Lagerver\-waltung &Customer / Supplier
  (Lagerverwaltung als Eigent\"umer) &Zutat ist in unserem
  Fall einfach die Menge der Zutat, welche im Lager
  zur Verf\"ugung steht und wird mit der Lagerverwaltung
  abgeglichen. Zutat verh\"alt sich analog zu Gericht. \\
% }}}
% Zutatenposition {{{
\hline
Zutaten\-position &Rezeptver\-waltung &Customer / Supplier
  (Rezeptverwaltung als Eigent\"umer) &vgl. Entity Gericht.
  \\
% }}}
% Sitzplatz {{{
\hline
Sitzplatz &Tischreser\-vierung &Separate Ways &Aus dem
  einfachen Grund, dass Sitzplatz bei uns etwas v\"ollig
  anderes ist, als beim Subsystem Tischreservierung, haben
  wir hier Separate Ways gew\"ahlt. W\"ahrend bei der
  Tischreservierung der physikalische Sitzplatz gemeint
  ist, bezieht sich unsere Definition von Sitzplatz auf
  die Instanz eines Gast-Clientprozesses, welches auf einem
  Tablet im Restaurant l\"auft. Der Gast gibt mit Hilfe
  dieses Programms seine Bestellungen auf. Da dies zwei
  v\"ollig unterschiedliche Dinge sind und eigentlich nur
  der Name der Entities gleich ist, haben wir uns hier
  f\"ur Separate ways entschieden. \\
% }}}
\hline
\end{longtabu}
% }}}
% }}}

% Teilaufgabe 2 {{{
\subsection{Teilaufgabe 2: Aggregates}

Im Folgenden beziehen wir uns unter anderem auf unsere
Aggregates aus Kapitel \ref{ms3_aggregates}. Die einzige
Unterscheidung zu diesem Aggregate ist, dass wir die
redundante Entity Speise (in Kapitel \ref{ldm} dem
Klassendiagramm des logischen Datenmodells hinzugef\"ugt,
um die Aufgabenstellung zu erf\"ullen) entfernen und das
Attribut $Speise.name$ in $Zubereitungsanleitung.name$
\"uberf\"uhren.

\begin{center}
% Tabelle {{{
\begin{tabu} to \linewidth {p{3cm}|X|X|X}
% Headerzeile {{{
\hline\rowcolor{codebordercolor}
Aggregate Root &Weitere beteiligte Entities &Invarianten
  &Begr\"undung, dass das ein Aggregate ist \\
% }}}
% Gericht {{{
\hline
Gericht &Zubereitungsanleitung, Zutatenposition, Zutat
  &\textit{Gericht.name} wird aus
  \textit{Zubereitungsanleitung.name}
  zusammengesetzt (Schnitzel, Pommes, Salat $\Rightarrow$
  \textit{Gericht.name} = Schnitzel mit Pommes und Salat)
  &vgl. \ref{ms3_aggregates} \\
% }}}
% Bestellung {{{
\hline
Bestellung & & &Entity Bestellung als eingenst\"andiges
  Aggregate, da es keine sinnvollen Zuordnungen gibt.\\
% }}}
% Speisekarte {{{
\hline
Speisekarte & & &vgl. Aggregate Bestellung. \\
% }}}
% Arbeitsplatz {{{
\hline
Arbeitsplatz & & &Entity aus unserem logischen Datenmodell,
  ohne \"Uberlappung zu anderen Subsystemen. Alleinstehend,
  da auch hier, wie beim Aggregate Bestellung keine
  sinnvollen Zuordnungen existieren. \\
% }}}
% Sitzplatz {{{
\hline
Sitzplatz & & &vgl. Aggregate Bestellung. \\
% }}}
\hline
\end{tabu}
% }}}
\end{center}
% }}}

\subsection{Teilaufgabe 3: Microservice-Architektur}

\subsubsection{Servicetabelle}

% Tabelle {{{
\begin{tabu} to \linewidth {X|X|X}
% Headerzeile {{{
\hline\rowcolor{codebordercolor}
Service &Bildet ab &Kommentar \\
% }}}
% Bestellung {{{
\hline
Bestellungen &Bestellung &Dient als API Gateway, da
  unser Subsystem ein Supplier f\"ur die Bestelldaten ist.
  \\
% }}}
% Gericht {{{
\hline
Gerichte &Gericht (vgl. \ref{ms3_aggregates})
  &Adapterservice, da unser Subsystem ein Customer f\"ur
  die Gerichtsdaten ist.\\
% }}}
% Speisekarte {{{
\hline
Speisekartenverwaltung &Speisekarte &Adapterservice, da
  unser Subsystem ein Customer f\"ur die Speisekartendaten
  ist.\\
% }}}
% Restaurant {{{
\hline
Restaurantverwaltung &Sitzplatz, Arbeitsplatz &Service der
  die Sitz- und Arbeitspl\"atze der Standorte verwaltet. \\
% }}}
% Gast-UI {{{
\hline
Gast-UI & &UI-Service f\"ur den Gast. Hier wird unserer
  Meinung nach kein API Gateway ben\"otigt, da das UI nur
  Daten aus dem Speisekartendaten-Service ben\"otigt und
  Bestellungen an den Bestellungsdaten-Service schickt,
  was weder eine besondere Darstellung der Daten ist, noch
  als viele verschiedene Aufrufe zu charakterisieren
  w\"are. \\
% }}}
% Koch-UI {{{
\hline
Koch-UI & &UI-Service f\"ur den Koch. Hier wird unserer
  Meinung nach kein API Gateway ben\"otigt, da nur Daten
  aus dem Gerichtsdaten-Service abgerufen werden m\"ussen.
  \\
% }}}
\hline
\end{tabu}
% }}}

\subsubsection{Komponentendiagramm}
\input{ms4/compo}

\subsubsection{Vergleich monolitisches Modell aus
  Meilenstein 2 mit Microservice-Modell}

% Tabelle {{{
\begin{tabu} to \linewidth {p{3cm}|X}
% Headerzeile {{{
\hline\rowcolor{codebordercolor}
Service &Entspricht / bildet ab auf Komponente aus MS 2 \\
% }}}
% Bestellung {{{
\hline
Bestellungen &Bestelldaten: Datenkomponente,
  Buchhaltungs-Api: Fassadenkomponente,
  Bestellabwicklung: Logikkomponente
  \\
% }}}
% Gericht {{{
\hline
Gerichte &Gerichtsdaten: Datenkomponente,
  Rezeptadapter: Adapterkomponente,
  Lagerverwaltungsadapter: Adapterkomponente
  \\
% }}}
% Speisekarte {{{
\hline
Speisekartenver\-waltung &Entspricht Tei der Gerichtsdaten:
  Datenkomponente, Rezeptadapter: Adapterkomponente \\
% }}}
% Restaurant {{{
\hline
Restaurantver\-waltung &Standortdaten: Datenkomponente \\
% }}}
% Gast-UI {{{
\hline
Gast-UI &Gast-UI: Dialogkomponente,
  Bestellvorgangsfassade: Fassadenkomponente \\
% }}}
% Koch-UI {{{
\hline
Koch-UI &An-/Abmeldungs-UI: Dialogkomponente,
  An-/Abmeldungsfassade: Fassadenkomponente,
  Zubereitungs-UI: Dialogkomponente,
  Zubereitungsfassade: Fassadenkomponente
  \\
% }}}
\hline
\end{tabu}
% }}}

\subsubsection*{Was sind aus Ihrer Sicht die Vorteile der
  einen oder anderen Architektur?}

Unserer Meinung nach hat die Microservice-Architektur den
Vorteil der \"Ubersichtlichkeit und der losen Kopplung.
Allein vom Modell wirkt die Microservice-Architektur
\"uberschaulicher (zumindest im Rahmen unseres Subsystems).
Des weiteren gef\"allt uns die klare Definition von
Schnittstellen und deren Implementierung \"uber
Netzwerkprotokolle wie HTTP.

Hier sehen wir allerdings auch einen Vorteil der
monolitischen Anwendung, da diese nicht auf die eher
allgemein gehaltenen Schnittstellen angwiesen ist uns so,
unserer Meinung nach, mehr Freiraum bietet.

\subsubsection*{Welche Architektur w\"urden Sie umsetzen,
  wenn Sie das als Informatikprojekt implementieren
  m\"ussten und wieso?}

Die Microservice-Architektur, da sie, allein vom Modell,
\"ubersichtlicher wirkt. Die lose Kopplung der Services und
die einheitlichen Schnittstellen gefallen uns sehr gut.
Unser Subsystem ist vom Implementierungsaufwand, unserer
Meinung nach, eher gering, weshalb die Menge an Komponenten
des monolitischen Modells abschreckend wirkt.

Unabh\"angig davon erfreut sich die Microservice-
Architektur momentan gro{\ss}er Beliebtheit, was wir auch
als Vorteil sehen.
